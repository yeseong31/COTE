# 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다.
# 반면 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.
# 다만 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도는 느리다.
# 따라서 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.

# DFS는 깊이 우선 탐색 알고리즘이다.
# 특정한 경로로 탐색다하가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘이다.

# (1) 탐색을 시작할 노드를 스택에 삽입 및 방문 처리
# (2) 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 삽입 및 방문 처리
#     그렇지 않으면 스택에서 최상단 노드를 pop
# (3) (2)번의 과정을 더 이상 수행할 수 없을 때까지 반복

# DFS는 스택 자료구조에 기초한다는 점에서 구현이 간단하다.
# 데이터의 개수가 N개인 경우 O(N)의 시간이 소요된다는 특징이 있다.
# 또한 DFS는 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀 함수를 이용했을 때 매우 간결해진다.

# ---------------------------------------------------------------------------------------------------------------------
# DFS 메서드 정의 
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)


# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3, 8],  # 1번 노드 -> 2, 3, 8번 노드와 연결
    [1, 7],     # 2번 노드 -> 1, 7번 노드와 연결
    [1, 4, 5],  # ...
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]      # 8번 노드 - 1, 7번 노드와 연결
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
